const g=/^(\[)?(\.\.\.)?(\w+)(?:=(\w+))?(\])?$/;function x(n){const s=[];return{pattern:n==="/"?/^\/$/:new RegExp(`^${w(n).map(a=>{const c=/^\[\.\.\.(\w+)(?:=(\w+))?\]$/.exec(a);if(c)return s.push({name:c[1],matcher:c[2],optional:!1,rest:!0,chained:!0}),"(?:/(.*))?";const u=/^\[\[(\w+)(?:=(\w+))?\]\]$/.exec(a);if(u)return s.push({name:u[1],matcher:u[2],optional:!0,rest:!1,chained:!0}),"(?:/([^/]+))?";if(!a)return;const t=a.split(/\[(.+?)\](?!\])/);return"/"+t.map((e,o)=>{if(o%2){if(e.startsWith("x+"))return f(String.fromCharCode(parseInt(e.slice(2),16)));if(e.startsWith("u+"))return f(String.fromCharCode(...e.slice(2).split("-").map(_=>parseInt(_,16))));const i=g.exec(e);if(!i)throw new Error(`Invalid param: ${e}. Params and matcher names can only have underscores and alphanumeric characters.`);const[,l,p,m,d]=i;return s.push({name:m,matcher:d,optional:!!l,rest:!!p,chained:p?o===1&&t[0]==="":!1}),p?"(.*?)":l?"([^/]*)?":"([^/]+?)"}return f(e)}).join("")}).join("")}/?$`),params:s}}function $(n){return!/^\([^)]+\)$/.test(n)}function w(n){return n.slice(1).split("/").filter($)}function v(n,s,h){const a={},c=n.slice(1),u=c.filter(r=>r!==void 0);let t=0;for(let r=0;r<s.length;r+=1){const e=s[r];let o=c[r-t];if(e.chained&&e.rest&&t&&(o=c.slice(r-t,r+1).filter(i=>i).join("/"),t=0),o===void 0){e.rest&&(a[e.name]="");continue}if(!e.matcher||h[e.matcher](o)){a[e.name]=o;const i=s[r+1],l=c[r+1];i&&!i.rest&&i.optional&&l&&e.chained&&(t=0),!i&&!l&&Object.keys(a).length===u.length&&(t=0);continue}if(e.optional&&e.chained){t++;continue}return}if(!t)return a}function f(n){return n.normalize().replace(/[[\]]/g,"\\$&").replace(/%/g,"%25").replace(/\//g,"%2[Ff]").replace(/\?/g,"%3[Ff]").replace(/#/g,"%23").replace(/[.*+?^${}()|\\]/g,"\\$&")}export{v as e,w as g,x as p};
