import{S as we,i as me,s as ve,k as r,q as l,a as p,l as a,m as f,r as n,h as t,c as d,n as h,T as be,b as i,D as s,E as ee}from"../chunks/index.e52fc4ee.js";const ce=""+new URL("../assets/better-i18n-demo.9d09ebe6.gif",import.meta.url).href;function ye(ue){let w,C,I,x,G,k,b,L,P,T,M,W,c,j,R,E,J,z,y,N,F,H,Q,B,_,V,D,m,X,v,Y,Z,U,u,te,K,S,$,O,q,g;return{c(){w=r("h1"),C=l("Roadmap"),I=p(),x=r("p"),G=l(`T18S is not done. There is still a lot we want to add. Here are some of our
ideas for the future in no particular order.`),k=p(),b=r("h2"),L=l("Robustness"),P=p(),T=r("p"),M=l(`T18S is still relatively new, and hasn’t handled all the edge cases yet. This causes occasional
problems with the dev-server, reloading translations and other inconveniences. We want to make sure
that t18s is as robust as possible and can deliver the best experience possible.`),W=p(),c=r("h2"),j=l("Support more File Formats"),R=p(),E=r("p"),J=l(`There exists a wide range of file formats for translations. We want to support as many of them as possible
in order to allow developers and translators to use the tools they are most comfortable with.`),z=p(),y=r("h2"),N=l("Built in Internationalized Routing"),F=p(),H=r("p"),Q=l(`SvelteKit currently doesn’t offer a built in way to internationalize routes. It’s left
to the developer to implement this. We want to provide a standard and straight forward
way to do this. Due to the complexity of the problem there are still a lot of open questions here,
and there is a lot of experimenting left to be done.`),B=p(),_=r("h2"),V=l("Interactive Translation"),D=p(),m=r("p"),X=l(`There are a few proof-of-concept tools & sites out there that push the
boundary of how we interact with the things we build. One of those is
`),v=r("a"),Y=l("better-i18n-for-svelte"),Z=l(`.
It’s a proof of concept for editing translations in your dev-browser directly,
instead of in files.`),U=p(),u=r("img"),K=p(),S=r("p"),$=l(`We want to experiment with implementing features like this in t18s. There are a lot of open questions
with this though. How do we determine which text came from a translation? How do we handle variable interpolation
in the editor, how do we add new translations?`),O=p(),q=r("p"),g=l("Until we have answers to these questions, this will remain relatively low priority."),this.h()},l(e){w=a(e,"H1",{id:!0});var o=f(w);C=n(o,"Roadmap"),o.forEach(t),I=d(e),x=a(e,"P",{});var oe=f(x);G=n(oe,`T18S is not done. There is still a lot we want to add. Here are some of our
ideas for the future in no particular order.`),oe.forEach(t),k=d(e),b=a(e,"H2",{id:!0});var ie=f(b);L=n(ie,"Robustness"),ie.forEach(t),P=d(e),T=a(e,"P",{});var se=f(T);M=n(se,`T18S is still relatively new, and hasn’t handled all the edge cases yet. This causes occasional
problems with the dev-server, reloading translations and other inconveniences. We want to make sure
that t18s is as robust as possible and can deliver the best experience possible.`),se.forEach(t),W=d(e),c=a(e,"H2",{id:!0});var re=f(c);j=n(re,"Support more File Formats"),re.forEach(t),R=d(e),E=a(e,"P",{});var le=f(E);J=n(le,`There exists a wide range of file formats for translations. We want to support as many of them as possible
in order to allow developers and translators to use the tools they are most comfortable with.`),le.forEach(t),z=d(e),y=a(e,"H2",{id:!0});var ae=f(y);N=n(ae,"Built in Internationalized Routing"),ae.forEach(t),F=d(e),H=a(e,"P",{});var ne=f(H);Q=n(ne,`SvelteKit currently doesn’t offer a built in way to internationalize routes. It’s left
to the developer to implement this. We want to provide a standard and straight forward
way to do this. Due to the complexity of the problem there are still a lot of open questions here,
and there is a lot of experimenting left to be done.`),ne.forEach(t),B=d(e),_=a(e,"H2",{id:!0});var fe=f(_);V=n(fe,"Interactive Translation"),fe.forEach(t),D=d(e),m=a(e,"P",{});var A=f(m);X=n(A,`There are a few proof-of-concept tools & sites out there that push the
boundary of how we interact with the things we build. One of those is
`),v=a(A,"A",{href:!0,rel:!0,target:!0});var he=f(v);Y=n(he,"better-i18n-for-svelte"),he.forEach(t),Z=n(A,`.
It’s a proof of concept for editing translations in your dev-browser directly,
instead of in files.`),A.forEach(t),U=d(e),u=a(e,"IMG",{src:!0,width:!0,height:!0,loading:!0,alt:!0}),K=d(e),S=a(e,"P",{});var pe=f(S);$=n(pe,`We want to experiment with implementing features like this in t18s. There are a lot of open questions
with this though. How do we determine which text came from a translation? How do we handle variable interpolation
in the editor, how do we add new translations?`),pe.forEach(t),O=d(e),q=a(e,"P",{});var de=f(q);g=n(de,"Until we have answers to these questions, this will remain relatively low priority."),de.forEach(t),this.h()},h(){h(w,"id","roadmap"),h(b,"id","robustness"),h(c,"id","support-more-file-formats"),h(y,"id","built-in-internationalized-routing"),h(_,"id","interactive-translation"),h(v,"href","https://github.com/versiobit/better-i18n-for-svelte"),h(v,"rel","noopener noreferrer"),h(v,"target","_blank"),be(u.src,te=ce)||h(u,"src",te),h(u,"width","1100"),h(u,"height","700"),h(u,"loading","lazy"),h(u,"alt","Better i18n for Svelte allowing you to click on some text and edit it directly in the browser. The changes are then saved to disk.")},m(e,o){i(e,w,o),s(w,C),i(e,I,o),i(e,x,o),s(x,G),i(e,k,o),i(e,b,o),s(b,L),i(e,P,o),i(e,T,o),s(T,M),i(e,W,o),i(e,c,o),s(c,j),i(e,R,o),i(e,E,o),s(E,J),i(e,z,o),i(e,y,o),s(y,N),i(e,F,o),i(e,H,o),s(H,Q),i(e,B,o),i(e,_,o),s(_,V),i(e,D,o),i(e,m,o),s(m,X),s(m,v),s(v,Y),s(m,Z),i(e,U,o),i(e,u,o),i(e,K,o),i(e,S,o),s(S,$),i(e,O,o),i(e,q,o),s(q,g)},p:ee,i:ee,o:ee,d(e){e&&t(w),e&&t(I),e&&t(x),e&&t(k),e&&t(b),e&&t(P),e&&t(T),e&&t(W),e&&t(c),e&&t(R),e&&t(E),e&&t(z),e&&t(y),e&&t(F),e&&t(H),e&&t(B),e&&t(_),e&&t(D),e&&t(m),e&&t(U),e&&t(u),e&&t(K),e&&t(S),e&&t(O),e&&t(q)}}}class xe extends we{constructor(w){super(),me(this,w,null,ye,ve,{})}}export{xe as component};
