import { VIRTUAL_MODULE_PREFIX } from "../constants.js";
import { addQuotes, stringTypeUnion } from "../utils/stringUtils.js";

/**
 * Write a d.ts file that incorporates all the translations for all locales.
 *
 * @param {import("../types.js").LocaleDictionaries} localeDictionaries
 */
export function generateDTS(localeDictionaries) {
  const locales = [...localeDictionaries.keys()];
  const messageKeys = new Set();

  for (const dictionary of localeDictionaries.values()) {
    for (const key of dictionary.keys()) {
      messageKeys.add(key);
    }
  }

  let code = `// FILE AUTOGENERATED BY t18s
  // You can safely add this to your .gitignore
  
  /**
   * TypeSafe translations for your Svelte app.
   */
  declare module '${VIRTUAL_MODULE_PREFIX}' {
      import type { Writable, Readable } from 'svelte/store';
  
      /**
       * The known locales
       */
      export type Locale = ${stringTypeUnion(locales)};
  
      /**
       * A store containing the available locales.
       * 
       * Note: This store will only ever change during development, it is constant in production.
       */
      export const locales : Readable<readonly [${locales
        .map(addQuotes)
        .join(",")}]>;
        
      /**
       * The current locale
       */
      export const locale: Writable<Locale>;
  
      /**
       * Set the current locale. Equivalent to \`locale.set(newLocale)\`
       * @param newLocale The new locale
       */
      export function setLocale(newLocale: Locale): void;
  
      /**
       * If the current locale is still being loaded.
       */
      export const isLoading: Readable<boolean>;
  
      /**
       * Initialize t18s.
       * This must be called before any other t18s function.
       */
      export function init(options: { initialLocale: Locale, fallbackLocale?: Locale, loadingDelay?: number }) : Promise<void>
  
  
      /**
       * Preloads the translations for the given locale. 
       * This can be used to anticipate a locale change.
       * 
       * Maybe preload the locale of the user's browser, since they're likely to switch to that.
       */
      export const preloadLocale: (newLocale: Locale) => Promise<void>;
  
      /**
       * Convenience function to check if something is a valid locale.
       */
      export const isLocale: (maybeLocale: unknown) => maybeLocale is Locale;
  
      export type Messages = {
  `;

  //Loop over all keys, and generate a type for each key.
  //The type of a key is the intersection of the types of the key in each locale.
  //Make sure to handle empty types (i.e. {}) correctly.
  for (const key of messageKeys) {
    code += `        "${key}": `;

    /**
     * The type for this key in each locale.
     * @type {import("../types.js").Message[]}
     */
    let messages = [];

    for (const locale of locales) {
      const dictionary = localeDictionaries.get(locale);
      if (!dictionary) continue;
      const message = dictionary.get(key);
      if (message && message.typeDefinition) {
        messages.push(message);
      }
    }

    if (messages.length === 0) {
      code += "undefined";
    } else {
      code += messages
        .map((message) => `(${message.typeDefinition})`)
        .join(" & ");
    }

    code += ",\n";
  }

  code += "    };\n\n";

  code += `
      /**
       * The translation function.
       * @param key A translation key.
       * @param values Any values that are interpolated into the translation.
       */
      export const t : Writable<<Key extends keyof Messages>(key: Key, ...values: (Messages[Key] extends undefined ? [(undefined | {})?] : [Messages[Key]])) => string>;
  }
    `;
  return code;
}
