import { addQuotes, stringTypeUnion } from "./utils/stringUtils.js";
import { DTSBuilder } from "./utils/dtsBuilder.js";
import { VIRTUAL_MODULE_PREFIX } from "../constants.js";
import { MessageCatalogue } from "../MessageCatalogue.js";

/**
 * @param {import("../types.js").ResolvedPluginConfig} config
 * @param {MessageCatalogue} Catalogue
 */
export function generateDTS(config, Catalogue) {
  const locales = config.locales;
  const messagesTypeMap = generateMessagesTypeMap(config, Catalogue);

  const dts = new DTSBuilder();
  dts.setDisclaimer(
    "FILE AUTOGENERATED BY t18s\nYou can safely add this to your .gitignore",
  );

  dts.addModule(VIRTUAL_MODULE_PREFIX, (module) => {
    module.setDescription("TypeSafe translations for your Svelte app.");
    module.addImport("import type { Writable, Readable } from 'svelte/store';");

    module.addStatement(
      `type Locales = [${[...locales].map(addQuotes).join(",")}];`,
      (s) => s.setDescription("The available locales"),
    );

    module.addStatement(`export type Locale = Locales[number];`, (s) =>
      s.setDescription("The known locales"),
    );


    module.addStatement(`export const fallbackLocale: Locale | undefined;`, (s) =>
      s.setDescription("The fallback locale that's currently in use.")
    );

    module.addStatement(`export const locales : Locales;`, (s) =>
      s.setDescription(
        "A store containing the available locales.\n\nThis store will only ever change during development, it is constant in production.",
      ),
    );

    module.addStatement(`export const locale: Writable<Locale>;`, (s) =>
      s.setDescription("The current locale"),
    );

    module.addStatement(
      "export function setLocale(newLocale: Locale): void;",
      (s) =>
        s.setDescription(
          "Set the current locale. Equivalent to `locale.set(newLocale)`\n@param newLocale The new locale",
        ),
    );

    module.addStatement("export const isLoading: Readable<boolean>;", (s) =>
      s.setDescription("If the current locale is still being loaded."),
    );

    module.addStatement(
      "export function init(options: { initialLocale: Locale, fallbackLocale?: Locale, loadingDelay?: number }) : Promise<void>",
      (s) =>
        s.setDescription(
          "Initialize t18s.\nThis must be called before any other t18s function.",
        ),
    );

    module.addStatement(
      `export const preloadLocale: (newLocale: Locale) => Promise<void>;`,
      (s) =>
        s.setDescription(
          [
            "Preloads the translations for the given locale.",
            "This can be used to anticipate a locale change.",
            "",
            "Maybe preload the locale of the user's browser, since they're likely to switch to that.",
          ].join("\n"),
        ),
    );

    module.addStatement(
      "export const isLocale: (maybeLocale: unknown) => maybeLocale is Locale;",
      (s) =>
        s.setDescription(
          "Convenience function to check if something is a valid locale.",
        ),
    );

    let messagesType = "type Messages = {\n";
    //Loop over all keys, and generate a type for each key.
    //The type of a key is the intersection of the types of the key in each locale.
    //Make sure to handle empty types (i.e. {}) correctly.
    for (const [key, type] of messagesTypeMap.entries()) {
      messagesType += `    "${key}": ${type},\n`;
    }

    messagesType += "};";

    module.addStatement(messagesType, (s) =>
      s.setDescription("Available Translations and their Arguments"),
    );

    // t Store
    module.addStatement(
      "export const t : Writable<<Key extends keyof Messages>(key: Key, ...values: (Messages[Key] extends undefined ? [(undefined | {})?] : [Messages[Key]])) => string>;",
      (s) =>
        s.setDescription(
          [
            "The translation store.",
            "@param key A translation key.",
            "@param values Any values that are interpolated into the translation.",
          ].join("\n"),
        ),
    );
  });

  return dts.build();
}

/**
 * @param {import("../types.js").ResolvedPluginConfig} config
 * @param {MessageCatalogue} Catalogue
 * @returns {Map<string, string>}
 */
function generateMessagesTypeMap(config, Catalogue) {
  /**
   * Maps a key to it's set of messages across all locales
   * @type {Map<string, Set<import("../types.js").Message>>}
   */
  const key2messages = new Map();

  for (const [_, domain, dictionary] of Catalogue.getDictionaries().entries()) {
    for (const [messageKey, message] of dictionary.entries()) {
      const key =
        domain === config.defaultDomain ? messageKey : `${domain}:${messageKey}`;
      if (!key2messages.has(key)) key2messages.set(key, new Set());
      key2messages.get(key)?.add(message);
    }
  }

  const messagesTypeMap = new Map();
  for (const [key, messages] of key2messages.entries()) {
    /** @type {Set<string>} */
    const types = new Set();

    for (const message of messages) {
      if (message.typeDefinition) types.add(message.typeDefinition);
    }

    if (types.size === 0) {
      messagesTypeMap.set(key, "undefined");
    } else {
      messagesTypeMap.set(key, [...types].join(" & "));
    }
  }

  return messagesTypeMap;
}
