import { VIRTUAL_MODULE_PREFIX } from "../../constants.js";
import { addQuotes, stringTypeUnion } from "../../utils/stringUtils.js";

/**
 * An t18s adapter that uses Svelte stores to store the translations.
 */
export class SvelteStoreAdapter {
  /** @type {import("vite").ViteDevServer | null} */
  #server = null;

  /** @type {import("../../types.js").ResolvedPluginConfig} */
  #config;

  /** @param {import("../../types.js").ResolvedPluginConfig}  config*/
  constructor(config) {
    this.#config = config;
  }

  /**
   * @param {import("vite").ViteDevServer | null} server
   */
  useServer(server) {
    this.#server = server;
  }

  /**
   * @param {import("../../types.js").LocaleDictionaries} localeDictionaries
   * @returns {string}
   */
  getTypeDefinition(localeDictionaries) {
    return generateDTS(localeDictionaries);
  }

  /**
   * @param {import("../../types.js").LocaleDictionaries} localeDictionaries
   * @returns {string}
   */
  getMainCode(localeDictionaries) {
    const locales = [...localeDictionaries.keys()];
    return generateMainModuleCode(locales, this.#config.verbose);
  }

  /**
   * @param {import("../../types.js").Dictionary} dictionary
   */
  getDictionaryCode(dictionary) {
    return generateDictionaryModule(dictionary);
  }

  /**s
   * @param {string} locale
   * @returns {void}
   */
  HMRAddLocale(locale) {
    this.#triggerHMREvent("createLocale", locale);
  }

  /**
   * @param {string} locale
   * @returns {void}
   */
  HMRInvalidateLocale(locale) {
    this.#triggerHMREvent("invalidateLocale", locale);
  }

  /**
   * @param {string} locale
   * @returns {void}
   */
  HMRRemoveLocale(locale) {
    this.#triggerHMREvent("removeLocale", locale);
  }

  /**
   * Triggers a HMR event, causing the browser to react to translation changes.
   *
   * @param {"createLocale" | "invalidateLocale" | "removeLocale"} event
   * @param {string} locale
   * @returns {void}
   */
  #triggerHMREvent(event, locale) {
    if (this.#server) {
      this.#server.ws.send({
        type: "custom",
        event: "t18s:" + event,
        data: {
          locale,
        },
      });
    }
  }
}

/**
 * Write a d.ts file that incorporates all the translations for all locales.
 *
 * @param {import("../../types.js").LocaleDictionaries} localeDictionaries
 */
function generateDTS(localeDictionaries) {
  const locales = [...localeDictionaries.keys()];
  const messageKeys = new Set();

  for (const dictionary of localeDictionaries.values()) {
    for (const key of dictionary.keys()) {
      messageKeys.add(key);
    }
  }

  let code = `// FILE AUTOGENERATED BY t18s
// You can safely add this to your .gitignore

/**
 * TypeSafe translations for your Svelte app.
 */
declare module '${VIRTUAL_MODULE_PREFIX}' {
    import type { Writable, Readable } from 'svelte/store';

    /**
     * The known locales
     */
    export type Locale = ${stringTypeUnion(locales)};

    /**
     * A store containing the available locales.
     * 
     * Note: This store will only ever change during development, it is constant in production.
     */
    export const locales : Readable<readonly [${locales
      .map(addQuotes)
      .join(",")}]>;
      
    /**
     * The current locale
     */
    export const locale: Writable<Locale>;

    /**
     * Set the current locale. Equivalent to \`locale.set(newLocale)\`
     * @param newLocale The new locale
     */
    export function setLocale(newLocale: Locale): void;

    /**
     * If the current locale is still being loaded.
     */
    export const isLoading: Readable<boolean>;

    /**
     * Initialize t18s.
     * This must be called before any other t18s function.
     */
    export function init(options: { initialLocale: Locale, fallbackLocale?: Locale, loadingDelay?: number }) : Promise<void>


    /**
     * Preloads the translations for the given locale. 
     * This can be used to anticipate a locale change.
     * 
     * Maybe preload the locale of the user's browser, since they're likely to switch to that.
     */
    export const preloadLocale: (newLocale: Locale) => Promise<void>;

    /**
     * Convenience function to check if something is a valid locale.
     */
    export const isLocale: (locale: unknown) => locale is Locale;

    export type Messages = {
`;

  //Loop over all keys, and generate a type for each key.
  //The type of a key is the intersection of the types of the key in each locale.
  //Make sure to handle empty types (i.e. {}) correctly.
  for (const key of messageKeys) {
    code += `        "${key}": `;

    /**
     * The type for this key in each locale.
     * @type {import("../../types.js").Message[]}
     */
    let messages = [];

    for (const locale of locales) {
      const dictionary = localeDictionaries.get(locale);
      if (!dictionary) continue;
      const message = dictionary.get(key);
      if (message && message.typeDefinition) {
        messages.push(message);
      }
    }

    if (messages.length === 0) {
      code += "undefined";
    } else {
      code += messages
        .map((message) => `(${message.typeDefinition})`)
        .join(" & ");
    }

    code += ",\n";
  }

  code += "    };\n\n";

  code += `
    /**
     * The translation function.
     * @param key A translation key.
     * @param values Any values that are interpolated into the translation.
     */
    export const t : Writable<<Key extends keyof Messages>(key: Key, ...values: (Messages[Key] extends undefined ? [(undefined | {})?] : [Messages[Key]])) => string>;
}
  `;
  return code;
}

/**
 * Generates the code for the "$t18s" module
 * @param {string[]} locales
 * @param {boolean} verbose
 * @returns {string}
 */
function generateMainModuleCode(locales, verbose) {
  return `
import { writable, get } from 'svelte/store';

const messages = {}

export const locales = writable(${JSON.stringify(locales)});
export const locale = writable(null);
export const setLocale = locale.set;
export const isLoading = writable(false);

const loaders = {
${locales.map(
  (locale) =>
    `    "${locale}": async () => (await import("$t18s/messages/${locale}")).default`
)}
}

let fallbackLocale = undefined;
let loadingDelay = 200;

export async function init(options) {
  
  if(!options.initialLocale) throw new Error("[t18s] No initial locale provided when calling \`init\`");
  locale.set(options.initialLocale);

  if(options.fallbackLocale) {
    fallbackLocale = options.fallbackLocale;
  }

  if(options.loadingDelay !== undefined) {
    loadingDelay = options.loadingDelay;
  }

  try {
    const promises = [];
    promises.push(preloadLocale(options.initialLocale));
    if(options.fallbackLocale) promises.push(preloadLocale(options.fallbackLocale));
    await Promise.all(promises);
  } catch(e) {
    throw new Error("[t18s] Failed to load initial locale " + options.initialLocale + ": " + e.message, {cause: e});
  }
}

//Load the given locale quietly in the background
//May throw
export async function preloadLocale(newLocale) {
  const newMessages = await loaders[newLocale]();
  messages[newLocale] = newMessages;
}

const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

export function isLocale(maybeLocale) {
  return get(locales).includes(maybeLocale);
}

async function loadLocale(newLocale) {
  let done = false;
  try {
    //To avoid showing the loading state too much, we allow a small delay before showing the loading state.
    sleep(loadingDelay).then(() => {if(!done) isLoading.set(true)});
    await preloadLocale(newLocale);
  } catch(e) {
    console.error("[t18s] Failed to load locale " + newLocale + ": " + e.message);
  } finally {
    isLoading.set(false);
    done = true;
  }
}

const getMessage = (key, values = undefined) => {
  const currentLocale = get(locale);

  if(currentLocale === null) {
    throw new Error("[t18s] No locale set. Did you forget to call \`init\`?");
  }

  if(messages[currentLocale] && messages[currentLocale][key]) {
    return messages[currentLocale][key](values);
  } else if (fallbackLocale && messages[fallbackLocale] && messages[fallbackLocale][key]) {
    ${
      verbose
        ? 'console.debug("[t18s] Translation for key " + key + " not found in locale " + currentLocale +". Using fallback locale " + fallbackLocale);'
        : ""
    }
    return messages[fallbackLocale][key](values);
  }  else {
  ${
    verbose
      ? 'console.warn("[t18s] Translation for key " + key + " not found in locale " + currentLocale);'
      : ""
  }
    return key;
  }
}

export const t = writable(getMessage);

//Update the store when the locale changes
locale.subscribe((newLocale) => {
  if(newLocale === null) return;
  if(newLocale in messages) {
    t.set(getMessage)
  } else {
    loadLocale(newLocale).then(() => t.set(getMessage));
  }
});

if(import.meta.hot) { 

  import.meta.hot.on("t18s:createLocale", async (data) => {
    locales.update((locales) => [...locales, data.locale]);

    //Force-reload the module - Add a random query parameter to bust the cache
    const newMessages = (await import(/* @vite-ignore */ "/@id/__x00__$t18s/messages/" + data.locale + "?" + Math.random())).default;

    ${verbose ? ' console.info("[t18s] Adding locale " + data.locale);' : ""}

    messages[data.locale] = newMessages;
    t.set(getMessage); //update the store
  });

  import.meta.hot.on("t18s:invalidateLocale", async (data) => {
    //Force-reload the module - Add a random query parameter to bust the cache
    const newMessages = (await import(/* @vite-ignore */ "/@id/__x00__$t18s/messages/" + data.locale + "?" + Math.random())).default;
   

    ${verbose ? 'console.info("[t18s] Reloading locale " + data.locale);' : ""}

    messages[data.locale] = newMessages;
    t.set(getMessage); //update the store
  });
  
  import.meta.hot.on("t18s:removeLocale", async (data) => {
    ${verbose ? 'console.info("[t18s] Removing locale " + data.locale);' : ""}

    delete messages[data.locale];

    locales.update((locales) => locales.filter((l) => l !==  data.locale));

    if(data.locale === get(locale)) {
      locale.set(get(locales)[0]);
    }

    t.set(getMessage); //update the store
  });
}
`;
}

/**
 * Generates the code for the `$t18s/messages/<locale>` modules.
 *
 * @param {import("../../types.js").Dictionary} dictionary
 * @returns {string}
 */
function generateDictionaryModule(dictionary) {
  let code = "";
  code += "export default {\n";
  for (const [key, func] of dictionary) {
    code += `    "${key}": ${func.precompiled},\n`;
  }
  code += "};";
  return code;
}
