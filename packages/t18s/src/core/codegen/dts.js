import { addQuotes } from "./utils/stringUtils.js";
import { DTSBuilder } from "./utils/dtsBuilder.js";
import { VIRTUAL_MODULE_PREFIX } from "../constants.js";
import { MessageCatalogue } from "../MessageCatalogue.js";

/**
 * @param {import("../types.js").ResolvedPluginConfig} config
 * @param {MessageCatalogue} Catalogue
 */
export function generateDTS(config, Catalogue) {
  const locales = config.locales;

  const dts = new DTSBuilder();
  dts.setDisclaimer(
    "FILE AUTOGENERATED BY t18s\nYou can safely add this to your .gitignore"
  );

  dts.addModule(VIRTUAL_MODULE_PREFIX, (module) => {
    module.setDescription("TypeSafe translations for your Svelte app.");
    module.addImport("import type { Writable, Readable } from 'svelte/store';");

    module.addStatement(
      `type Locales = [${[...locales].map(addQuotes).join(",")}];`,
      (s) => s.setDescription("The available locales")
    );

    module.addStatement(`export type Locale = Locales[number];`, (s) =>
      s.setDescription("The known locales")
    );

    module.addStatement(
      `export const fallbackLocale: ${
        config.fallbackLocale ? addQuotes(config.fallbackLocale) : undefined
      };`,
      (s) => s.setDescription("The fallback locale that's currently in use.")
    );

    module.addStatement(`export const locales : Locales;`, (s) =>
      s.setDescription("The available locales")
    );

    module.addStatement(`export const locale: Writable<Locale>;`, (s) =>
      s.setDescription("The current locale")
    );

    module.addStatement(
      "export function setLocale(newLocale: Locale): void;",
      (s) =>
        s.setDescription(
          "Set the current locale. Equivalent to `locale.set(newLocale)`\n@param newLocale The new locale"
        )
    );

    module.addStatement(
      "export const isLocale: (maybeLocale: unknown) => maybeLocale is Locale;",
      (s) =>
        s.setDescription(
          "Convenience function to check if something is a valid locale."
        )
    );
  });

  const domains = Catalogue.getDomains();

  for (const domain of domains) {
    addMessageModule(config, dts, Catalogue, domain);
  }

  return dts.build();
}

/**
 * @param {import("../types.js").ResolvedPluginConfig} config
 * @param {DTSBuilder} dts
 * @param {MessageCatalogue} Catalogue
 * @param {string} domain
 */
function addMessageModule(config, dts, Catalogue, domain) {
  /**
   * Maps a key to it's set of messages across all locales
   * @type {Map<string, Set<import("../types.js").Message>>}
   */
  const key2messages = new Map();

  for (const [locale, dictionary] of Catalogue.getMessages(domain)) {
    for (const [key, message] of dictionary.entries()) {
      if (!key2messages.has(key)) key2messages.set(key, new Set());
      key2messages.get(key)?.add(message);
    }
  }

  const moduleId =
    domain === "" ? "$t18s/messages" : `$t18s/messages/${domain}`;

  dts.addModule(moduleId, (module) => {
    module.setDescription(
      `The messages for the domain ${domain}. Add messages by adding a file at ${config.translationsDir} with the name ${domain}.[locale].yaml`
    );
    module.addImport("import type { Readable } from 'svelte/store';");

    for (const [key, messages] of key2messages.entries()) {
      /** @type {Set<string>} */
      const types = new Set();

      for (const message of messages) {
        if (message.typeDefinition) types.add(message.typeDefinition);
      }

      if (types.size === 0) {
        module.addStatement(
          `export const ${key}: Readable<(values?: undefined) => string>;`
        );
      } else {
        module.addStatement(
          `export const ${key}: Readable<(values : ${[...types].join(
            " & "
          )}) => string>;`
        );
      }
    }
  });
}
