import { addQuotes, indent } from "./utils/stringUtils.js";
import { DTSBuilder } from "./utils/dtsBuilder.js";
import { VIRTUAL_MODULE_PREFIX } from "../constants.js";
import { MessageCatalogue } from "../MessageCatalogue.js";
import { parse } from "@formatjs/icu-messageformat-parser";
import { generateType } from "../../../compiler/generateTypes.js";
import { Tree } from "../utils/Tree.js";

/**
 * @param {import("../types.js").ResolvedPluginConfig} config
 * @param {MessageCatalogue} Catalogue
 */
export function generateDTS(config, Catalogue) {
  const locales = config.locales;

  const dts = new DTSBuilder();
  dts.setDisclaimer(
    "FILE AUTOGENERATED BY t18s\nYou can safely add this to your .gitignore"
  );

  dts.addModule(VIRTUAL_MODULE_PREFIX, (module) => {
    module.setDescription("TypeSafe translations for your Svelte app.");
    module.addImport("import type { Writable, Readable } from 'svelte/store';");

    module.addStatement(
      `type Locales = [${[...locales].map(addQuotes).join(",")}];`,
      (s) => s.setDescription("The available locales")
    );

    module.addStatement(`export type Locale = Locales[number];`, (s) =>
      s.setDescription("The known locales")
    );

    module.addStatement(
      `export const fallbackLocale: ${
        config.fallbackLocale ? addQuotes(config.fallbackLocale) : undefined
      };`,
      (s) => s.setDescription("The fallback locale that's currently in use.")
    );

    module.addStatement(`export const locales : Locales;`, (s) =>
      s.setDescription("The available locales")
    );

    module.addStatement(`export const locale: Writable<Locale>;`, (s) =>
      s.setDescription("The current locale")
    );

    module.addStatement(
      "export function setLocale(newLocale: Locale): void;",
      (s) =>
        s.setDescription(
          "Set the current locale. Equivalent to `locale.set(newLocale)`\n@param newLocale The new locale"
        )
    );

    module.addStatement(
      "export const isLocale: (maybeLocale: unknown) => maybeLocale is Locale;",
      (s) =>
        s.setDescription(
          "Convenience function to check if something is a valid locale."
        )
    );
  });

  const domains = Catalogue.getDomains();

  for (const domain of domains) {
    addMessageModule(config, dts, Catalogue, domain);
  }

  return dts.build();
}

/**
 * @param {import("../types.js").ResolvedPluginConfig} config
 * @param {DTSBuilder} dts
 * @param {MessageCatalogue} Catalogue
 * @param {string} domain
 */
function addMessageModule(config, dts, Catalogue, domain) {
  /** @type {Tree<string>[]} */
  let dictionaries = [];
  for (const [locale, dictionary] of Catalogue.getMessages(domain)) {
    dictionaries.push(dictionary);
  }

  let merged = Tree.mergeTrees(dictionaries);

  //Map over the tree, and generate types for each message.
  const typeDefinitions = merged.map((messages) => {
    /** @type {Set<string>} */
    const types = new Set();

    for (const message of messages) {
      const parsed = parse(message, {
        shouldParseSkeletons: true,
        requiresOtherClause: false,
      });
      const typeDefinition = generateType(parsed);
      if (typeDefinition) types.add(typeDefinition);
    }

    if (types.size === 0) return "undefined";
    return [...types].join(" & ");
  });

  const moduleId =
    domain === "" ? "$t18s/messages" : `$t18s/messages/${domain}`;

  dts.addModule(moduleId, (module) => {
    module.setDescription(
      `The messages for the domain ${domain}. Add messages by adding a file at ${config.translationsDir} with the name ${domain}.[locale].yaml`
    );
    module.addImport("import type { Readable } from 'svelte/store';");

    const code = treeToType(typeDefinitions);
    module.addStatement(code);
  });
}

/**
 * Turns a tree into a type definition.
 * @param {Tree<string>} tree
 * @returns {string}
 */
function treeToType(tree) {
  /**
   * @param {Tree<string>} tree
   *
   * @returns {string}
   */
  function walk(tree) {
    /** @type {string[]} */
    const lines = [];

    for (const [key, value] of tree.children()) {
      if (value instanceof Tree) {
        let line = "";
        line += `export namespace ${key} {\n`;
        const innerCode = walk(value);

        line += indent(innerCode, 4);
        line += "\n}";
        lines.push(line);
      } else {
        if (value === "undefined") {
          lines.push(
            `export const ${key}: Readable<(values?: undefined) => string>`
          );
        } else {
          lines.push(
            `export const ${key}: Readable<(values: ${value}) => string>`
          );
        }
      }
    }

    return lines.join(";\n");
  }

  return walk(tree);
}
